# 枚举
  ## 方法
    - 确定解空间(一维、二维)
    - 确定空间的边界(每个变量的最小值、最大值、步长)
    - 估算时间复杂度
    - 如果上一步无法通过则减小枚举空间、变换枚举顺序重新迭代
  ## 典型
    百钱买百鸡
     
# 排序
  ## 冒泡/选择
    我的笔记里暂时不写这俩
  ## 插入
    第一个元素看作已经排序好的了，然后从前往后遍历
    可以想象成扑克牌，我们拿出来一张往前比较，到他的位置插进去
    这里i代表我们的扑克牌
    j代表正在进行比较的牌
    但是这里就有一个问题，我们假设第一个元素是排好的了，可是如果第一个元素没有排好怎么办
    所以要在i对应的循环内再添加俩变量代表值和循环结束后插入的位置
```python
import sys
n = int(input())
a = list(map(int , sys.stdin.readline().split()))
for i in range(1, n):
    value = a[i]
    insert_idx = 0
    for j in range(i - 1 , -1 , -1):
        if a[j] > value:
            a[j + 1] = a[j]
        else:
            insert_idx = j + 1
            break
    a[insert_idx] = value
print(' '.join(map(str , a)))

```
  ## 快速排序
    首先找一个基准值(一般是left)
    把列表分成3部分 小于基准，大于基准，等于基准
    然后左右再执行该策略 
```python
import sys
def huafen(a,left,right):
    idx = left + 1
    for i in range (left+1,right+1):
        if a[i] < a[left]:
            a[i],a[idx] = a[idx],a[i]
            idx += 1
    a[idx-1],a[left] = a[left],a[idx-1]
    return idx - 1
def qs(a,left,right):
    if left < right:
        mid=huafen(a,left,right)
        #a[left:mid],a[mid],a[mid:right]
        qs(a,left,mid-1)
        #不要拍mid
        qs(a,mid+1,right)



n = int(input())
a = list(map(int, sys.stdin.readline().split()))
qs(a,0,n-1)
print(' '.join(map(str,a)))

```
  ## 归并排序
```python
import sys
def merge(a,b):
    result = []
    while len(a)!=0 and len(b)!=0:
        if a[0] < b[0]:
            result.append(a.pop(0))
        else:
            result.append(b.pop(0))
    result.extend(a)
    result.extend(b)
    return result
def merge_sort(a):
    if len(a) < 2:
        return a
    mid = len(a)//2
    left = merge_sort(a[:mid])
    right = merge_sort(a[mid:])
    return merge(left,right)
n = int(input())
a = list(map(int, sys.stdin.readline().split()))
a = merge_sort(a)
print(' '.join(map(str, a)))


```
  ## 桶排序
    初始化k个桶
    遍历数据到桶中
    桶单独排序
    拼接桶
    